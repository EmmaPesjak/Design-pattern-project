# Project Report
Emma Pesjak


## Environment & Tools
This project was performed on a Windows 10 PC with IntelliJ version 2022.2.3, Java version openjdk 19.0.1, 
maven version 3.8.5, and Git version 2.33.0.windows.2.


## Purpose
The purpose of this project was to demonstrate a comprehensive understanding of the course's learning
objectives. Specifically, to create an event-driven application with a Graphical User Interface (GUI) using 
Java Swing. The goal was to achieve a grade as high as possible and thereby showcase the utilization of the
Swing library and implement a range of different layouts and components. Furthermore, to incorporate the use of 
Streams API and to use concurrent synchronized processes in an atomic fashion. Lastly also to demonstrate the 
use of design patterns. While having the entire code structured according to the Model-View-Controller (MVC) 
pattern, also incorporating the observer, object pool, producer/consumer, factory method, abstract factory,
and template method patterns.

To summarize the concrete goals:
* Create an event-driven application with a GUI.
* Have a minimum of five concurrent processes, where at least 3 are synchronized.
* Include at least six different Swing components and four different layouts.
* Use the seven design patterns mentioned above.
* Implement at least three uses of Streams API.


## Procedures
As the MVC pattern was the base structure for this project...

något generellt här
generell kodstruktur

MODEL
mainmodel
här fick jag in streams API , annars basic fakta eftersom resten tas upp i underrubrikerna
the different models (?) are described in greater detail below in each design pattern.

VIEW
The view is the front of the application, where the user...
här fick jag in layouts och components och event-driven UI
problem: duplicate images could not be displayed since the Jlabel was created in Constants interface,
by instead only setting it to imageicons and making new labels when needed this was fixed
problem that occured: mosterna ritas inte ut, någon form av race condition?? efersom de randomas fram.
fixades med revalidate/repaint i updatePanel()
egna button och panel klasser för att spara massa rader kod eftersom alla bakgrunder är likadana och
alla butttons är likadana.
Om jag inte skriver tillräckligt specifikt om viewsen här får jag lägga till mer i template method.

beskriva att olika levels har olika views...

CONTROLLER
finns en controller, interface och två buttonlistenerklasser, controllern har många inre listenerklasser men 
de får vara kvar eftersom man i dem gör val som påverkar view/model. quit och next bröts ut för att koden i controller
inte skulle bli för lång.

lägger in allt som kan ändras i spelet i constants för att det ska finnas på ett ställe och vara lätt
har dock namnen på monsterna i sina klasser

Skriva om JAR och pom?
A problem that occurred during the creation of JAR file...
FETT PROBLEM IMAGES -> ImageReader klass

### Producer/consumer pattern
The producer/consumer pattern was used in the healing simulation in level 5. It was also here that the concurrent 
synchronized processes were implemented by having seven threads, producers and consumers, accessing the shared resource
of health. Two classes for the different actors were created, one `HealThread` representing the producer and one 
`DamageThread` representing the consumer, see figure 1. These classes were very similar, they both implemented the 
`Runnable` interface, and had a private volatile boolean that was used to control the lifetime of the thread. They both 
had a `stopThread()` method which simply set the boolean to false and thereby terminating the thread in the overridden
`run()` method. The `run()` method contained a while loop that ran as long as the boolean was set to true. The 
`HealThread`'s `run()` method simply randomized a healing amount which it communicated to the class `Vaelarya` via the 
`addHealth(int healAmount)` method, it then slept for a set number of seconds. 

The `Vaelarya` class represented the dragon's health bar in the simulation and was also implemented as a Singleton.
In addition to the `addHealth()` method, `Vaelarya` also had a `removeHealth()` method which was used by the 
`DamageThread`. The `DamageThread`'s `run()` method used a `Weapon` from the `WeaponDistributor` as described below 
in the object pool pattern section.  If a weapon was available, the thread would first sleep for a set amount of
seconds, representing the time it took the monster to swing the weapon. It would then use the weapon by calling
`Vaelarya`'s `removeHealth(int damageAmount)` method with the integer damage of the weapon. It would then return the 
weapon to the distributor and sleep again for a set amount of seconds representing rest time. However, if no weapon 
was available the thread would simply sleep for a set amount of seconds representing wait time.

![](UMLProducerConsumer.png)
<br>Figure 1: UML diagram of the producer/consumer pattern.

### Observer pattern
The observer pattern was also used for the healing simulation in level 5, see figure 2 for a UML diagram describing it.
To start the simulation, the user would press a button with an action listener which called the `Controller`s 
`initLevel5()` method. This method would create and start the `DamageThread`s and `HealThread` used in the simulation, 
it also added itself as an observer to the `Vaelarya` class and start a timer. The timer called the `updateLevel5View()`
method every 150ms. This method simply communicated with the view, updating it with a new `HealthBarPanel` depicting 
the current health of the dragon. To be able to get the current health, two interfaces, `Observer` and `Observable`, 
were implemented. The `Observable` interface contained methods for adding and notifying observers. This interface was
implemented by the observable class `Vaelarya`, which overrode the methods of the interface. The method for adding 
observers simply took an observer as an argument and added this to a list of observers. The method for notifying 
observers looped over the list of observers and called each observer's update method. This meant that the `Observer` 
interface needed to have a method for updating, which was its only method. The `Controller` class implemented this 
interface and overrode the method, checking the current amount of health from an instance of the `Vaelarya` class with 
the `getHealth()` method. Based on if the current health was above the set upper health or equal to or below 0, the 
`Controller` would end the simulation, stop the timer, terminate the threads, and set up the end view. If the amount 
of health was somewhere in between the simulation would continue. 

![](UMLObserver.png)
<br>Figure 2: UML diagram of the observer pattern. Note that the `Controller` class contains several more inner 
classes which are not relevant for the observer pattern.

### Object pool pattern
The object pool pattern was implemented as a `WeaponDistributor`, which held a pool of `Weapon`s used by the client
`DamageThread`, see figure 3 for a UML diagram describing the pattern. The client would ask the distributor for a 
reusable weapon to use and then return when finished with it. The `WeaponDistributor` class was implemented as a 
Singleton. In the private constructor, three `Weapon`s were created and added to a blocking queue. Methods for
borrowing and returning weapons were also added to this class. The `Weapon` class had a single method for getting 
the weapon damage, this was randomized with the upper limit set in the `Constants` interface.

A concurrency problem that occurred was that during the testing of the program a `ConcurrentModificationException` 
would sometimes trigger. This was because the weapons list was first implemented as an ordinary deque. By using a 
blocking queue instead, which is thread-safe, the problem was fixed.

![](UMLObjectPool.png)
<br> Figure 3: UML diagram of the implemented object pool pattern.

### Factory method and Abstract factory pattern
Two factories were implemented in the program; the `MonsterFactory` and the `UnicornFactory` both of these extended 
the AbstractFactory interface. Figure 4 displays a UML diagram of the factory patterns. 

`MonsterFactory`.


Problem that occured
DETTA VAR JU FÖR FAN EN SIMPLE FACTORY!!!


Headfirst: "Is that a factory method lurking inside the
Abstract Factory?
Good catch! Yes, often the methods of an Abstract Factory are
implemented as factory methods. It makes sense, right? The job of an
Abstract Factory is to define an interface for creating a set of products.
Each method in that interface is responsible for creating a concrete
product, and we implement a subclass of the Abstract Factory to
supply those implementations. So, factory methods are a natural way to
implement your product methods in your abstract factories."


![](UMLFactory.png)
<br>Figure 4: UML diagram of the factory method and abstract factory patterns. Note that the `MainModel` class 
contains several more methods which are not relevant for the factory patterns.

### Template method pattern
Since the different views were quite similar when it came to base layout, the template method pattern was implemented 
to optimize the code. This let the concrete subclasses follow the algorithm in the base class, but each subclass 
decided how to implement each step. The abstract class `BaseView` was implemented as a base class. This defined the
method `makePanel()` for creating the panel to be added to the GUI frame. The panel consisted of smaller panels 
(top, center, and bottom) and an action listener for a button, these all had a method for implementation. They 
also had hooks in case the concrete views decided not to implement all of them. A method for updating the GUI frame 
with the panel was also added to the `BaseView`. Each concrete subclass, see figure 5, extended `BaseView` and overrode
its methods, deciding how the GUI should look, and decided if the hooks should be used.

![](UMLTemplate.png)
<br>Figure 5: UML diagram of the template method used for the different views.


## Discussion

"lab2
The observer pattern was one of the main designs of this assignment. There are slightly different variations of the
observer pattern, and for this laboration, the pattern described in the course literature was used. What could be
slightly confusing about the observer pattern is that the observer `Manager` has a `ResourcePool` when the Observable
interface has an observer interface, see figure 1. But since the object that is being observed is already passed into
the constructor, we do not have to pass anything in when we call `update()`. Usually, the observer pattern´s observable
also has a `removeObserver()` method. However, such a method was not necessary for this program since no observer ever
needs to be removed.
The producer/consumer pattern is however not implemented in the code exactly as described in the course literature
since the resource pool consists of an integer, not tasks, which makes a queue or a blockingqueue that is commonly used
in this pattern redundant.
As threads are used in the program, the code had to be made thread safe in order to not have concurrency issues.
This can be done in a few different ways, by adding locks, adding synchronized blocks, synchronizing whole methods etc.
Declaring methods synchronized adds Java built in locks and this was chosen for the program as the methods with
possible concurrency risks did not have many lines of code. If they had been larger with more or broader functionality,
perhaps a synchronized block had been preferable. `Manager:update()`, `ResourcePool:addResources()`,
`ResourcePool:removeResources()`, and `ResourcePool:getAmountOfResources()` were made synchronized since these are
dependent on that only one thread at a time run the method, or else concurrency issues may occur, for example the
amount of resources in the pool will be incorrect if two threads add resources at the same time.
"

"lab 3
The MVC pattern was the foundation for this laboration. One of the benefits with using the MVC pattern is that it is
easily planned. The interface code belongs in the view, the data in the model, and the communication and requests in
the controller. This increases the scalability of the application.
The `View` class contains a lot of different sizes, dimensions and a few colors. If this was a larger application
where they would be reused, they should be put in constants, considering the size of this application, that is not
necessary. An action listener was chosen for communication between the View and the Controller.  To create the GUI,
different Swing layouts and components were used.
Streams API can be used for a range of things, here the `stream.reduce()` method was used which was very convenient
for calculating the sum of the user input, rather than doing it in a loop. In conclusion, this laboration could have
been a lot larger with parallel processing, multiple Views etc. Though it is a simple solution, it fulfills the
concrete goals of the purpose, creating a program using Swing, MVC, and streams API.
"

object pool pattern:
object pool pattern används ofta med ett annat syfte, när kostnaden av att initiera
ett object är väldigt hög, och därmed återbrukas dem. Här är kanske kostnaden inte
så hög för just klassen weapon men det demonstrerar en object pool pattern.
så det fulfillar purpose.
weapon distributor måste vara thread-safe med en blocking queue
Object pool och producer/consumer från object pool discussion:
"The other way we could approach this would be to use AtomicInteger rather than primitive
int or the base Integer object. This will actually guarantee complete thread safety for us
and make sure that all operations are done atomically, in an ordered fashion. The tradeoff 
here is that we introduce a little more overhead since it involves Compare and Swap 
Instructions, but this is a small price to pay for the benefits of atomic abstraction. 
One could also make a strong case for added cohesion with this approach since all matters
surrounding concurrency are isolated to one entity rather than spread over multiple. 
In our case we only have a single method which modifies the value, but you could perhaps 
imagine having several procedures each making different modifications.
So by using AtomicInteger we no longer need to declare synchronized blocks explicitly.

Whether to use volatile together with explicit synchronization or use AtomicInteger are for
the most part arbitrary, but there are some occasions where one should be preferred over the 
other. The former can become an issue in multi-core systems where each CPU runs in isolation.
The JVM is rather poor in ensuring visibility between closed subsystems, especially when each 
one run instructions from cached memory. But at the same time we also have some minor
overhead with atomic datatypes which could impact performance. For our design we go with 
the first alternative but the only reason is to get a better separation of concerns, for
learning purposes."


template method: snacka om hooks


kunda ha delat upp model i de olika levels? särskilt om man har mer avancerade levels.


hade det varit ett större spel hade man kunnat dela in main model mer på olika levels.

snacka om att det är bra med att ha alla konstanter på ett ställe, att man kanske även kan lägga in alla 
strängar här, så det endast är ett ställe att uppdatera på om man gör ändringar i spelet.
notera att man inte kan ge vaelarya hur mycket hälsa som helst eller göra ordlistan för lång utan att fucka UIt.

factory:

abstract factory:

prod/cons: oftarst delade resurser i en blocking queue men jag kör en int. snacka om volitile boolean i trådarna. kunde skrivit ut mer info
i consol/till en log/i GUIt om fighten, vilka monster som använde vilket vapen, vilka som vilade etc

observer: har ofta en remove observer men den behövdes inte för programmet. har bara en observer, trots det gör jag en lista
och loopar ööver den vid uppdatering vilket kan kännas lite onödigt, however det är bra för framtiden om man vill bygga 
vidare på programmet och lägga till fler. Hade kanske kunnat lägga vaelarya inne i main model 
istället, men nu blev det tydligt.

Diskutera:
To summarize the concrete goals:
* Create an event-driven application with a GUI. 
    ja det har ju obv uppnåtts, event-driven där usern klickar på knappar/radiobuttons/combobox för att köra vidare spelet
* Have a minimum of five concurrent processes, where at least 3 are synchronized.
    visas i level 5 med simuleringen av draken där 7 trådar accessar health
* Include at least six different Swing components and four different layouts.
    jframe, jlabel, jradiobutton, jcombobox, jpanel, imageicon, jbutton, jtextfield
    gridlayout, borderlayout, gridbag layout, boxlayout, flowlayout
* Use the seven design patterns mentioned above.
    japp
* Implement at least three uses of Streams API.
    stream.reduce(), stream().sorted().collect(Collectors.toList()), stream().filter()

Perspective: Has the purpose been fulfilled? Determine the suitability of the implementation...
should alternative approaches and procedures be considered?

The two most important things we need in this section regards analyses of both success and implementation.
Has the purpose been fulfilled, and to what extent has it been successful? Remember to argue for such
success on the basis of actual results. The reader needs to be able to run the thread of logic
backwards from conclusion to its source in the results, so remember to maintain objectivity. 
If the statements leading to the conclusion contains any trace of subjectivity (I think... 
I believe... I feel... etc) it will remove all scientific value, rendering your reasoning void 
of substance.

Was the approaches and procedures suitable? Only the methodology is considered here, and we expect 
to see some dissection of the actual procedures. At this point in time you have already conducted 
the study and should possess more knowledge in comparison to what you had in the beginning. If you 
or someone else were to redo this study, what should be done differently?


### Execution of the program
When running the program, the user first encounters a general start screen with brief information about the game.
By pressing the 'start' button, the game then takes the user through five different levels, meeting random monsters on
each level. Level 1 presents the user with a list of words, which can be sorted or counted based on the user's selection 
in a combo box. By pressing the 'Next level' button, the game moves on to level 2. At this level, the user needs to help
the monster to place a certain amount of apples into different buckets. If the answer is correct, level 3 starts.
Here, the user can produce random monsters and unicorns from an abstract factory. Clicking on the 'Produce' button 
creates five characters. The user can proceed to the next level at any time by pressing the 'Next level' button.
Level 4 displays a riddle for the user to answer, if they do so correctly, they proceed to level 5. At this level,
the user meets Vaelarya Vision Walker, a dragon in need of help from evil monsters. By pressing the 'Channel crystal'
button, a simulation begins where Vaelarya is healed by the user and damaged by the monsters. When Vealarya is either
dead (0 hp or less) or completely healed to her maximum hp, the simulation ends automatically. The user then comes to 
an end view where there is a button for quitting the game and thereby shutting down the program. At any time during 
the game, the user can also quit the program by clicking on the 'X' in the upper right corner.

### Personal reflections
This course has given me a deeper knowledge of OOP and Java, dabbling into pom and JAR files, creating GUI 
applications, etc. The course material has been very helpful, however as I am a big fan of the teacher's notes, more 
of these would be appreciated. It is always good to read code written by teachers to understand the 
code/classes/patterns, how to structure larger programs, how to comment etc. The most difficult part of this project 
was to incorporate all the different design patterns while still conforming to MVC.
