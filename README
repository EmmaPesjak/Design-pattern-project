# Project Report
Emma Pesjak


## Environment & Tools
This project was performed on a Windows 10 PC with IntelliJ version 2022.2.3, Java version openjdk 19.0.1, 
maven version 3.8.5, and Git version 2.33.0.windows.2.


## Purpose
The purpose of this project was to demonstrate a comprehensive understanding of the course's learning
objectives. Specifically, to create an event-driven application with a Graphical User Interface (GUI) using 
Java Swing. The goal was to achieve a grade as high as possible and thereby showcase the utilization of the
Swing library and implement a range of different layouts and components. Furthermore, to incorporate the use of 
Streams API and to use concurrent synchronized processes in an atomic fashion. Lastly also to demonstrate the 
use of design patterns. While having the entire code structured according to the Model-View-Controller (MVC) 
pattern, also incorporating the observer, object pool, producer/consumer, factory method, abstract factory,
and template method patterns.

To summarize the concrete goals:
* Create an event-driven application with a GUI.
* Have a minimum of five concurrent processes, where at least 3 are synchronized.
* Include at least six different Swing components and four different layouts.
* Use the seven design patterns mentioned above.
* Implement at least three uses of Streams API.


## Procedures
The MVC pattern was the base structure and architecture used for this project. Different packages for models, views, 
and controllers contained almost all the classes and interfaces. A `Constants` interface was created in the support 
package. This interface contained defined constant values used throughout the program by the different classes.
A `Project` class directly under the project package was the program's main starting point and initiated the MVC start 
entities. The game consisted of 5 different levels with various implementations to fulfill all the project 
requirements. Each level was represented by a monster, read the 'Execution of the program' section below for more 
information about the levels. 

The `MainModel` class was responsible for handling the application's data, performing calculations, and 
communicating with the controller. The `MainModel` class was completely in charge of the logic for levels 1 and 2, 
and handled the communication with the controller for level 3. This class also created the monsters for each level 
with the `getRandomMonster()` method which used the `MonsterFactory` described in the factory subcategory below. 
For level 1 the `MainModel` had three methods: `level1RandomWords()`, `sortLevel1Alphabetically()`, and 
`countWordsLevel1()`. These methods produced different strings from a list of words to be used in the GUI depending 
on the choice of the user. This was also where two streams API methods were used. The 
`stream().sorted().collect(Collectors.toList())`, for sorting the list in alphabetical order, and the 
`stream().filter()` for counting words in the list that consisted of more than five letters. The third stream API
method was the `stream().reduce()` which was used by the `calculateLevel2(List<Integer> numbs)` method. This simply 
took a list of integers as arguments and calculated the sum of these. The integers came from the user input in 
level 2 via the controller. It then checked if the calculated value was equal to the set value in the `Constants` 
interface and returned a boolean. The rest of the classes in the models package are described in greater detail in 
the subcategories of design patterns below.

The view classes were responsible for creating the GUI for the application. The class `ViewFrame` initiated the JFrame 
and set the size and background. It had a method for updating the view, which took a panel as an argument, added it to 
the frame, and repainted/revalidated. It also had a method for displaying error messages. Since all the buttons of the 
application and almost all the panels had the same base design, the classes `MyButton` and `MyPanel` were created. These 
set the layout and looks of these components. A class `HealthBarPanel` for creating the health bar panel of level 
5 was also created. This class got the amount of health and color it was supposed to portray via the `Controller` 
and painted the graphics as a rectangle with it. Each level, as well as the start and end screens, 
had its own class for creating the panel to present in the GUI frame, extending the `BaseView` class with the 
template method pattern described in greater detail in the subcategory below. These classes set the design of the 
event-driven GUI, utilizing the Constants interface for colors and fonts. They used Swing components such as
`JLabel`, `JRadioButton`, `JCombobox`, `JPanel`, `ImageIcon`, `JButton`, and `JTextField`. They also used the
Swing layouts `GridLayout`, `BorderLayout`, `GridBagLayout`, `BoxLayout`, and `FlowLayout`. A problem that occurred 
during the creation of the JAR file was that the images used in the application were not displayed in the GUI. 
This was solved by placing all image .pngs in the resources directory and adding an `ImageReader` class. This class 
created JLabels with the ImageIcons from the URL by the class loader.

The `Controller` was responsible for communication with the models and the views, accessing data from the view,
telling the model to calculate the data, and then telling the view to update. The constructor initiated the different
level views, added action listeners to the buttons, and displayed the start view. The action listeners were implemented
as inner classes. The `Level1ComboboxListener` was responsible for listening to the combo box of level 1 and updating 
the UI with the help of the model depending on the choice of the user. The `Level2ButtonListener` and the
`Level4ButtonListener` was in their own ways responsible for checking if the user had answered correctly and either 
initiating the next level or displaying a message telling the user to try again. The `Level3ButtonListenerProduce` was 
responsible for telling the view to display produced characters from the model. The `Level5ButtonListener` was
simply responsible for initiating the level 5 simulation. The `NextLevelButtonListener` started the next level by 
making the panel of the view it received as an argument. The `QuitButtonListener` simply terminated the program.

### Producer/consumer pattern
The producer/consumer pattern was used in the healing simulation in level 5. It was also here that the concurrent 
synchronized processes were implemented by having seven threads, producers and consumers, accessing the shared resource
of health. Two classes for the different actors were created, one `HealThread` representing the producer and one 
`DamageThread` representing the consumer, see figure 1. These classes were very similar, their constructor took and set 
a `Vaelarya` which represented the dragon's health bar in the simulation. They both implemented the `Runnable` 
interface, and had a private volatile boolean that was used to control the lifetime of the thread. They both had a 
`stopThread()` method which simply set the boolean to false and thereby terminating the thread in the overridden
`run()` method. The `run()` method contained a while loop that ran as long as the boolean was set to true. The 
`HealThread`'s `run()` method simply randomized a healing amount which it communicated to the class `Vaelarya` via the 
`addHealth(int healAmount)` method, it then slept for a set number of seconds. In addition to the `addHealth()` method, 
`Vaelarya` also had a `removeHealth()` method which was used by the `DamageThread`. The `DamageThread`'s `run()` 
method used a `Weapon` from the `WeaponDistributor` as described below in the object pool pattern section. If a weapon 
was available, the thread would first sleep for a set amount of seconds, representing the time it took the monster 
to swing the weapon. It would then use the weapon by calling `Vaelarya`'s `removeHealth(int damageAmount)` method with 
the integer damage of the weapon. It would then return the weapon to the distributor and sleep again for a set amount 
of seconds representing rest time. However, if no weapon was available the thread would simply sleep for a set amount 
of seconds representing wait time.

![](UMLProducerConsumer.png)
<br>Figure 1: UML diagram of the producer/consumer pattern.

### Observer pattern
The observer pattern was also used for the healing simulation in level 5, see figure 2 for a UML diagram describing it.
To start the simulation, the user would press a button with an action listener which called the `Controller`s 
`initLevel5()` method. This method would create and start the `DamageThread`s and `HealThread` used in the simulation, 
it also added itself as an observer to the `Vaelarya` class and start a timer. The timer called the `updateLevel5View()`
method every 150ms. This method simply communicated with the view, updating it with a new `HealthBarPanel` depicting 
the current health of the dragon. To be able to get the current health, two interfaces, `Observer` and `Observable`, 
were implemented. The `Observable` interface contained methods for adding and notifying observers. This interface was
implemented by the observable class `Vaelarya`, which overrode the methods of the interface. The method for adding 
observers simply took an observer as an argument and added this to a list of observers. The method for notifying 
observers looped over the list of observers and called each observer's update method. This meant that the `Observer` 
interface needed to have a method for updating, which was its only method. The `Controller` class implemented this 
interface and overrode the method, checking the current amount of health from the `Vaelarya` with the `getHealth()` 
method. Based on if the current health was above the set upper health or equal to or below 0, the `Controller` would 
end the simulation, stop the timer, terminate the threads, and set up the end view. If the amount of health was 
somewhere in between the simulation would continue. 

![](UMLObserver.png)
<br>Figure 2: UML diagram of the observer pattern. Note that the `Controller` class contains several more inner 
classes which are not relevant for the observer pattern.

### Object pool pattern
The object pool pattern was implemented as a `WeaponDistributor`, which held a pool of `Weapon`s used by the client
`DamageThread`, see figure 3 for a UML diagram describing the pattern. The client would ask the distributor for a 
reusable weapon to use and then return when finished with it. The `WeaponDistributor` class was implemented as a 
Singleton. In the private constructor, three `Weapon`s were created and added to a blocking queue. Methods for
borrowing and returning weapons were also added to this class. The `Weapon` class had a single method for getting 
the weapon damage, this was randomized with the upper limit set in the `Constants` interface.

A concurrency problem that occurred was that during the testing of the program a `ConcurrentModificationException` 
would sometimes trigger. This was because the weapons list was first implemented as an ordinary deque. By using a 
blocking queue instead, which is thread-safe, the problem was fixed.

![](UMLObjectPool.png)
<br> Figure 3: UML diagram of the implemented object pool pattern.

### Factory method and Abstract factory pattern
Two factories were implemented in the program; the `MonsterFactory` and the `UnicornFactory`, both of these implemented 
the `AbstractFactory` interface. Figure 4 displays a UML diagram of the factory patterns. The `AbstractFactory` was set
to define an interface for creating a set of products; a character and a color, which defines the abstract factory
pattern. The `createChar()` and `createColor` methods were both responsible for creating concrete products. This was 
done by the subclasses with the factory method. Both the `MonsterFactory` class and the `UnicornFactory` class 
randomized which concrete product to create. Each concrete product extended either the abstract class `BaseCharacter`
or `BaseColor`, which had getters and setters for names and image paths respectively colors. Four methods were 
implemented in the `MainModel` class for getting random monsters, getting lists of random characters' image path and 
name, getting random colors, and getting random factories which were used by the two previous methods. 

A design problem that occurred here was that a simple factory was implemented instead of a factory method at first.
The factory method is often mistaken for the simple factory idiom, and when reviewing the course material this was
changed and the proper patterns were implemented.

![](UMLFactory.png)
<br>Figure 4: UML diagram of the factory method and abstract factory patterns. Note that the `MainModel` class 
contains several more methods which are not relevant for the factory patterns.

### Template method pattern
Since the different views were quite similar when it came to base layout, the template method pattern was implemented 
to optimize the code. This let the concrete subclasses follow the algorithm in the base class, but each subclass 
decided how to implement each step. The abstract class `BaseView` was implemented as a base class. This defined the
method `makePanel()` for creating the panel to be added to the GUI frame. The panel consisted of smaller panels 
(top, center, and bottom) and an action listener for a button, these all had a method for implementation. They 
also had hooks in case the concrete views decided not to implement all of them. A method for updating the GUI frame 
with the panel was also added to the `BaseView`. Each concrete subclass, see figure 5, extended `BaseView` and overrode
its methods, deciding how the GUI should look, and decided if the hooks should be used.

![](UMLTemplate.png)
<br>Figure 5: UML diagram of the template method used for the different views. Note that many of the arguments 
of the different methods are simply described as '(...)' in the figure to save space.


## Discussion
One of the concrete goals of the purpose was to create an event-driven application with a GUI. This goal has been 
achieved since the application certainly is event-driven as the user interacts with buttons, radio buttons, and
combo boxes in the GUI. The GUI has several views with lots of different graphical components which the user interacts 
with during the different levels. Another concrete goal was to include at least six different Swing components and four 
different layouts. This has also been achieved to the highest degree. The swing components used were as mentioned in
the procedures; `JFrame`, `JLabel`, `JRadioButton`, `JCombobox`, `JPanel`, `ImageIcon`, `JButton`, and `JTextField`.
The Swing layouts used were; `GridLayout`, `BorderLayout`, `GridBagLayout`, `BoxLayout`, and `FlowLayout`. Some 
components, such as the `JButton` and `JPanel` were frequently made from their own classes `MyButton` and `MyPanel`.
This allowed for generic looks in the GUI with significantly less code than if the attributes had been set each time 
a class would have made a button or panel.


to what level of completeness? 


SNACKA OM FILSTRUKTUR, VARFÖR JAG LA KLASSERNA DÄR JAG LA DEM

MVC

"lab 3
The MVC pattern was the foundation for this laboration. One of the benefits with using the MVC pattern is that it is
easily planned. The interface code belongs in the view, the data in the model, and the communication and requests in
the controller. This increases the scalability of the application.
The `View` class contains a lot of different sizes, dimensions and a few colors. If this was a larger application
where they would be reused, they should be put in constants, considering the size of this application, that is not
necessary. An action listener was chosen for communication between the View and the Controller.  To create the GUI,
different Swing layouts and components were used.
Streams API can be used for a range of things, here the `stream.reduce()` method was used which was very convenient
for calculating the sum of the user input, rather than doing it in a loop. In conclusion, this laboration could have
been a lot larger with parallel processing, multiple Views etc. Though it is a simple solution, it fulfills the
concrete goals of the purpose, creating a program using Swing, MVC, and streams API.
"



hade det varit ett större spel hade man kunnat dela in main model mer på olika levels.
kunda ha delat upp model i de olika levels? särskilt om man har mer avancerade levels.

* Implement at least three uses of Streams API.
  också kirrat
  stream.reduce(), stream().sorted().collect(Collectors.toList()), stream().filter()


lägger in allt som kan ändras i spelet i constants för att det ska finnas på ett ställe och vara lätt
snacka om att det är bra med att ha alla konstanter på ett ställe, att man kanske även kan lägga in alla
strängar här, så det endast är ett ställe att uppdatera på om man gör ändringar i spelet.
notera att man inte kan ge vaelarya hur mycket hälsa som helst eller göra ordlistan för lång utan att fucka UIt.


* Use the seven design patterns mentioned above.
  japp


vaelarya which is an observable could be implemented as a singelton... blablabla
"lab2
The observer pattern was one of the main designs of this assignment. There are slightly different variations of the
observer pattern, and for this laboration, the pattern described in the course literature was used. What could be
slightly confusing about the observer pattern is that the observer `Manager` has a `ResourcePool` when the Observable
interface has an observer interface, see figure 1. But since the object that is being observed is already passed into
the constructor, we do not have to pass anything in when we call `update()`. Usually, the observer pattern´s observable
also has a `removeObserver()` method. However, such a method was not necessary for this program since no observer ever
needs to be removed.
The producer/consumer pattern is however not implemented in the code exactly as described in the course literature
since the resource pool consists of an integer, not tasks, which makes a queue or a blockingqueue that is commonly used
in this pattern redundant.
As threads are used in the program, the code had to be made thread safe in order to not have concurrency issues.
This can be done in a few different ways, by adding locks, adding synchronized blocks, synchronizing whole methods etc.
Declaring methods synchronized adds Java built in locks and this was chosen for the program as the methods with
possible concurrency risks did not have many lines of code. If they had been larger with more or broader functionality,
perhaps a synchronized block had been preferable. `Manager:update()`, `ResourcePool:addResources()`,
`ResourcePool:removeResources()`, and `ResourcePool:getAmountOfResources()` were made synchronized since these are
dependent on that only one thread at a time run the method, or else concurrency issues may occur, for example the
amount of resources in the pool will be incorrect if two threads add resources at the same time.
"



template method: snacka om hooks

factory/abstract factory: fett förvirrande med simple factory, istället för att randomiza fram allt skulle man kunna specificera
allt. Producerar massa objekt, här får man vara försiktig

prod/cons: oftarst delade resurser i en blocking queue men jag kör en int. snacka om volitile boolean i trådarna. kunde skrivit ut mer info
i consol/till en log/i GUIt om fighten, vilka monster som använde vilket vapen, vilka som vilade etc
* Have a minimum of five concurrent processes, where at least 3 are synchronized.
  visas i level 5 med simuleringen av draken där 7 trådar accessar health. concrete goal!

observer: har ofta en remove observer men den behövdes inte för programmet. har bara en observer, trots det gör jag en lista
och loopar ööver den vid uppdatering vilket kan kännas lite onödigt, however det är bra för framtiden om man vill bygga
vidare på programmet och lägga till fler. Hade kanske kunnat lägga vaelarya inne i main model
istället, men nu blev det tydligt.

When multible synchrinized threads are used, thread safty is of utter importance...

object pool pattern:
object pool pattern används ofta med ett annat syfte, när kostnaden av att initiera
ett object är väldigt hög, och därmed återbrukas dem. Här är kanske kostnaden inte
så hög för just klassen weapon men det demonstrerar en object pool pattern.
så det fulfillar purpose.
weapon distributor måste vara thread-safe med en blocking queue
Object pool och producer/consumer från object pool discussion:
"The other way we could approach this would be to use AtomicInteger rather than primitive
int or the base Integer object. This will actually guarantee complete thread safety for us
and make sure that all operations are done atomically, in an ordered fashion. The tradeoff 
here is that we introduce a little more overhead since it involves Compare and Swap 
Instructions, but this is a small price to pay for the benefits of atomic abstraction. 
One could also make a strong case for added cohesion with this approach since all matters
surrounding concurrency are isolated to one entity rather than spread over multiple. 
In our case we only have a single method which modifies the value, but you could perhaps 
imagine having several procedures each making different modifications.
So by using AtomicInteger we no longer need to declare synchronized blocks explicitly.

Whether to use volatile together with explicit synchronization or use AtomicInteger are for
the most part arbitrary, but there are some occasions where one should be preferred over the 
other. The former can become an issue in multi-core systems where each CPU runs in isolation.
The JVM is rather poor in ensuring visibility between closed subsystems, especially when each 
one run instructions from cached memory. But at the same time we also have some minor
overhead with atomic datatypes which could impact performance. For our design we go with 
the first alternative but the only reason is to get a better separation of concerns, for
learning purposes."


### Execution of the program
When running the program, the user first encounters a general start screen with brief information about the game.
By pressing the 'start' button, the game then takes the user through five different levels, meeting random monsters on
each level. Level 1 presents the user with a list of words, which can be sorted or counted based on the user's selection 
in a combo box. By pressing the 'Next level' button, the game moves on to level 2. At this level, the user needs to help
the monster to place a certain amount of apples into different buckets. If the answer is correct, level 3 starts.
Here, the user can produce random monsters and unicorns from an abstract factory. Clicking on the 'Produce' button 
creates five characters. The user can proceed to the next level at any time by pressing the 'Next level' button.
Level 4 displays a riddle for the user to answer, if they do so correctly, they proceed to level 5. At this level,
the user meets Vaelarya Vision Walker, a dragon in need of help from evil monsters. By pressing the 'Channel crystal'
button, a simulation begins where Vaelarya is healed by the user and damaged by the monsters. When Vealarya is either
dead (0 hp or less) or completely healed to her maximum hp, the simulation ends automatically. The user then comes to 
an end view where there is a button for quitting the game and thereby shutting down the program. At any time during 
the game, the user can also quit the program by clicking on the 'X' in the upper right corner.

### Personal reflections
This course has given me a deeper knowledge of OOP and Java, dabbling into pom and JAR files, creating GUI 
applications, etc. The course material has been very helpful, however as I am a big fan of the teacher's notes, more 
of these would be appreciated. It is always good to read code written by teachers to understand the 
code/classes/patterns, how to structure larger programs, how to comment etc. The most difficult part of this project 
was to incorporate all the different design patterns while still conforming to MVC. I decided to make five levels very 
early on during the development to fit in all the objectives. In hindsight, and if I were to redo this project, I 
would perhaps have implemented fewer levels with more substance and user interaction instead.
